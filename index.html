<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="public/logo.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="public/logo.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="public/logo.png" />
    <link rel="stylesheet" href="demo/style.css">
    <title>GradientGL - WebGL Gradient Generator</title>
    <base href="/gradient-gl/">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        :root {
            color-scheme: only dark;
            background-color: black;
            --h: 270;
            --lo: hsl(var(--h) 50% 10% / 0.3);
            --md: hsl(var(--h) 50% 10% / 0.4);
            --bg: hsl(var(--h) 50% 10% / 0.5);
            --fg: hsl(var(--h) 0% 100%);
            --sh: hsl(var(--h) 0% 0% / 0.5);
            --pk0: #FF4488;
            --pk1: #EE4499;
            --sk2: #33114476;
            --sk3: #441A5576;
            --sk8: #AA55BB76;
            --zk2: #CC66CC;
            --spacing-xs: 0.6rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.4rem;
            --spacing-xl: 1.6rem;
            --input-height: 0.5rem;
            --thumb-size: 1rem;
            --radius-sm: .6rem;
            --radius-md: .8rem;
            --radius-lg: 1.4rem;
            --blur-amount: 20px;
            --shadow-lg: 0 0 2rem var(--sh);
            --shadow-md: 0 0 1rem var(--sh);
        }

        @font-face {
            font-family: krypton;
            font-style: normal;
            font-display: swap;
            font-weight: 600;
            src: url(https://cdn.jsdelivr.net/fontsource/fonts/monaspace-krypton@latest/latin-600-normal.woff2) format('woff2'), url(https://cdn.jsdelivr.net/fontsource/fonts/monaspace-krypton@latest/latin-600-normal.woff) format('woff');
        }

        * {
            font-family: krypton, monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            min-height: 100vh;
            display: grid;
            place-items: start center;
            user-select: none;
            padding-top: 10vh;
        }

        main {
            z-index: 1;
            /* background-color: var(--lo); */
            /* backdrop-filter: blur(var(--blur-amount)); */
            padding: var(--spacing-xl);
            border-radius: var(--radius-lg);
            /* box-shadow: var(--shadow-lg); */
            color: var(--fg);
            min-width: 20rem;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        @media (pointer: coarse) and (hover: none) {
            main {
                position: fixed;
                inset: 0;
                width: 80vw;
                height: 90vh;
                padding: 1rem;
                margin: 5em auto;
                /* min-width: unset;
                max-width: 100vw;
                width: 100vw; */
                border-radius: 0;
                overflow-y: auto;
            }
        }

        /* display: grid; */
        /* gap: var(--spacing-lg);
            place-content: stretch; */
        /* justify-items: center; */
        /* margin: 1em; */
        /* margin-top: 0; */

        main.hidden {
            opacity: 0;
            visibility: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        button {
            opacity: 0.6;
            padding: var(--spacing-xs) var(--spacing-md);
            text-align: center;
            text-transform: uppercase;
            background: var(--sk3);
            border: none;
            box-shadow: none;
            outline: none;
            border-radius: var(--radius-md);
            transition: all 0.2s;
            cursor: pointer;
            color: var(--pk0);
            box-shadow: 0 0 0.5rem var(--sk2);
            border: none;
            font-size: 1rem;

            &:hover {
                opacity: 0.6;
                background: var(--sk2);
            }

            /* &:focus {
                border-radius: var(--radius-md);
                background: yellow;
                border: none;
                box-shadow: none;
                outline: none;
            }

            &:active {
                border-radius: var(--radius-md);
                background: cyan;
                border: none;
                box-shadow: none;
                outline: none;
            } */

        }

        #toggle {
            position: fixed;
            top: var(--spacing-md);
            right: var(--spacing-md);
            z-index: 2;
            background: var(--bg);
            backdrop-filter: blur(var(--blur-amount));
            border: none;
            color: var(--pk0);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 1.2rem;
            box-shadow: var(--shadow-lg);
            transition: all 0.2s ease;

            mix-blend-mode: difference;
            display: inline-block;
            width: 3rem;
            height: 3rem;
            --svg: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23000' d='M15.25 2h-6.5A6.76 6.76 0 0 0 2 8.75v6.5A6.76 6.76 0 0 0 8.75 22h6.5A6.76 6.76 0 0 0 22 15.25v-6.5A6.76 6.76 0 0 0 15.25 2m1.63 11H7.12a1 1 0 0 1 0-2h9.76a1 1 0 0 1 0 2'/%3E%3C/svg%3E");
            /* background-color: currentColor; */
            /* background: var(--pk0); */
            -webkit-mask-image: var(--svg);
            mask-image: var(--svg);
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-size: 100% 100%;
            mask-size: 100% 100%;
        }

        #seed {
            position: fixed;
            top: var(--spacing-md);
            left: 50%;
            text-transform: uppercase;
            transform: translateX(-50%);
            backdrop-filter: blur(var(--blur-amount));
            /* background: var(--sk3); */
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            font-size: 2rem;
            text-align: center;
            /* color: var(--pk0); */
            z-index: 2;
            mix-blend-mode: difference;
            /* box-shadow: var(--shadow-lg); */

            &::before {
                content: '';
                display: inline-block;
                width: 3rem;
                height: 3rem;
                --svg: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23000' d='M6.6 11.397c0-2.726 0-4.089.843-4.936c.844-.847 2.201-.847 4.917-.847h2.88c2.715 0 4.073 0 4.916.847c.844.847.844 2.21.844 4.936v4.82c0 2.726 0 4.089-.844 4.936c-.843.847-2.201.847-4.916.847h-2.88c-2.716 0-4.073 0-4.917-.847s-.843-2.21-.843-4.936z'/%3E%3Cpath fill='%23000' d='M4.172 3.172C3 4.343 3 6.229 3 10v2c0 3.771 0 5.657 1.172 6.828c.617.618 1.433.91 2.62 1.048c-.192-.84-.192-1.996-.192-3.66v-4.819c0-2.726 0-4.089.843-4.936c.844-.847 2.201-.847 4.917-.847h2.88c1.652 0 2.8 0 3.638.19c-.138-1.193-.43-2.012-1.05-2.632C16.657 2 14.771 2 11 2S5.343 2 4.172 3.172' opacity='0.5'/%3E%3C/svg%3E");
                background-color: currentColor;
                -webkit-mask-image: var(--svg);
                mask-image: var(--svg);
                -webkit-mask-repeat: no-repeat;
                mask-repeat: no-repeat;
                -webkit-mask-size: 100% 100%;
                mask-size: 100% 100%;
            }
        }

        #shaders {
            display: grid;
            gap: var(--spacing-xs);
            width: 100%;
        }

        .shader-type {
            display: grid;
            grid-auto-flow: column;
            gap: var(--spacing-md);
            width: 100%;
        }

        .shader {
            opacity: 0.6;

            &[data-selected="true"] {
                background: var(--pk0);
                color: black;
                font-weight: bold;
                opacity: 1;
                box-shadow: 0 0 1rem var(--pk0);
            }
        }

        #options {
            display: grid;
            gap: var(--spacing-md);
            width: 90%;
            padding: 1em;
            margin: 1rem auto;
            border-radius: var(--radius-lg);
            /* background-color: var(--lo); */
            backdrop-filter: blur(var(--blur-amount));
            /* box-shadow: var(--shadow-md); */
        }

        input[type="range"] {
            width: 100%;
            height: var(--input-height);
            background-color: var(--sk3);
            border-radius: var(--radius-sm);
            appearance: none;
            position: relative;
            margin-top: 1.2rem;

            &::before {
                content: attr(title);
                position: absolute;
                left: 0;
                top: -1.2rem;
                color: var(--zk2);
                font-size: 0.9rem;
                opacity: 0.8;
            }

            &::after {
                content: attr(data-hex-value);
                position: absolute;
                right: 0;
                top: -1.2rem;
                color: var(--pk0);
                font-size: 0.9rem;
                font-weight: bold;
            }

            &::-webkit-slider-thumb {
                appearance: none;
                width: var(--thumb-size);
                height: var(--thumb-size);
                background-color: var(--pk0);
                opacity: 0.4;
                backdrop-filter: blur(var(--blur-amount));
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.2s ease;
                box-shadow: 0 0 0.5rem var(--sh);
                border: none;

                &:hover {
                    transform: scale(1.2);
                    background: var(--pk1);
                    opacity: 1;
                }
            }

            &::-moz-range-thumb {
                width: var(--thumb-size);
                height: var(--thumb-size);
                background-color: var(--pk0);
                opacity: 0.4;
                backdrop-filter: blur(var(--blur-amount));
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.2s ease;
                box-shadow: 0 0 0.5rem var(--sh);
                border: none;

                &:hover {
                    transform: scale(1.2);
                    background: var(--pk1);
                    opacity: 1;
                }
            }
        }

        .usage {
            font-family: monospace;
            font-size: 0.9rem;
            padding: var(--spacing-xs);
            border-radius: var(--radius-lg);
            opacity: 0.8;
            white-space: pre;
            overflow: hidden;
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 40rem;
            max-height: 30vh;
            margin-bottom: var(--spacing-xs);
            box-shadow: var(--shadow-lg);
            transition: transform 0.3s ease, opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1;
            background: var(--md);
            backdrop-filter: blur(var(--blur-amount));
        }

        .usage.hidden {
            transform: translateX(-50%) translateY(calc(100% + 1rem));
            opacity: 0;
            visibility: hidden;
        }

        .toast {
            position: fixed;
            bottom: var(--spacing-md);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg);
            backdrop-filter: blur(var(--blur-amount));
            color: var(--pk0);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: 1.2rem;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>

<body>
    <span id="seed"></span>
    <main>
        <div id="shaders"></div>
        <div id="options"></div>
        <div class="usage"></div>
    </main>
    <div class="toast">URL copied to clipboard</div>
    <script type="module">
        import gradient from './index.js'
        import shaders from './shaders/index.js'
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0'

        const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x)
        const setProps = (el, props) => {
            if (!props) return el
            for (const [k, v] of Object.entries(props)) {
                if (k === 'dataset') {
                    for (const [dk, dv] of Object.entries(v)) {
                        el.dataset[dk] = dv
                    }
                } else {
                    el[k] = v
                }
            }
            return el
        }

        const mkEl = (tag, props = {}, children = []) => {
            const el = document.createElement(tag)
            setProps(el, props)
            if (children?.length) {
                for (const child of children) el.append(child)
            }
            return el
        }

        const query = document.querySelector.bind(document)
        const getEl = document.getElementById.bind(document)

        // Debounce function to prevent too many updates
        const debounce = (fn, delay = 100) => {
            let timeout
            return (...args) => {
                clearTimeout(timeout)
                timeout = setTimeout(() => fn(...args), delay)
            }
        }

        // Usage interface state
        const usageState = {
            update: async () => {
                const usage = query('.usage');
                const currentSeed = controlState.seed;

                const example = `import gradientGL from "gradient-gl"\n\nawait gradientGL("${currentSeed}")`;

                const html = await codeToHtml(example, {
                    lang: 'javascript',
                    theme: 'laserwave',
                    // theme: 'min-dark',
                    transformers: [
                        {
                            pre(node) {
                                delete node.properties.style;
                                return node;
                            }
                        }
                    ]
                });

                usage.innerHTML = html;
            }
        }

        // Control interface state
        const controlState = {
            seed: '',
            isVisible: true,
            update: debounce(async () => {
                const shader = query('.shader[data-selected="true"]')?.dataset.shader
                if (!shader) return

                const values = ['speed', 'hue', 'saturation', 'lightness']
                    .map(id => parseInt(getEl(id).value, 10).toString(16).toLowerCase());

                const newSeed = `${shader}.${values.join('')}`
                if (newSeed === controlState.seed) return

                controlState.seed = newSeed
                getEl('seed').textContent = controlState.seed
                await gradient(controlState.seed)
                usageState.update()

                // Only clear URL hash if this is not the initial load
                if (window.location.hash && !window.location.hash.includes(controlState.seed)) {
                    window.location.hash = ''
                }
            }, 50)
        }

        // Load seed from URL hash if present
        const loadSeedFromUrl = () => {
            const hash = window.location.hash.slice(1)
            if (!hash) return false

            console.log('Loading seed from URL:', hash)
            const [shader, values] = hash.split('.')
            if (!shader || !values || values.length !== 4) {
                console.log('Invalid seed format:', hash)
                return false
            }

            // Split values into individual hex digits
            const hexValues = values.split('')

            // Set shader
            const shaderBtn = query(`.shader[data-shader="${shader}"]`)
            if (!shaderBtn) {
                console.log('Shader not found:', shader)
                return false
            }

            document.querySelectorAll('.shader').forEach(opt => {
                opt.dataset.selected = opt === shaderBtn ? 'true' : 'false'
            })

            // Set values
            const ids = ['speed', 'hue', 'saturation', 'lightness']
            hexValues.forEach((value, i) => {
                const input = getEl(ids[i])
                if (!input) return
                const intValue = parseInt(value, 16)
                input.value = intValue
                input.dataset.hexValue = value
            })

            console.log('Successfully loaded seed from URL')
            return true
        }

        // UI Components
        const createRangeInput = ({ id, label }) => {
            const input = mkEl('input', {
                type: 'range',
                id,
                title: label,
                min: 0,
                max: 15,
                value: 7,
                dataset: { hexValue: '7' },
                oninput: (e) => {
                    e.target.dataset.hexValue = e.target.value.toString(16).toLowerCase();
                    controlState.update();
                }
            });
            return input;
        }

        const createShaderOption = shader => mkEl('button', {
            className: 'shader',
            textContent: shader,
            dataset: { shader },
            onclick: (e) => {
                const target = e.target
                document.querySelectorAll('.shader').forEach(opt => {
                    opt.dataset.selected = opt === target ? 'true' : 'false'
                })
                controlState.update()
            }
        })

        if (!shaders?.length) {
            console.error('No shaders available')
        }

        // Create shader UI
        getEl('shaders').append(
            ...Object.values(
                shaders.reduce((acc, shader) => {
                    acc[shader[0]] = [...(acc[shader[0]] || []), shader]
                    return acc
                }, {})
            ).map(variations =>
                mkEl('div', { className: 'shader-type' },
                    variations.map(createShaderOption)))
        )

        // Generate random option values
        const randomizeOptions = () => {
            // Randomize shader
            const randomShader = shaders[Math.floor(Math.random() * shaders.length)];
            const shaderButtons = document.querySelectorAll('.shader');
            shaderButtons.forEach(btn => {
                btn.dataset.selected = btn.dataset.shader === randomShader ? 'true' : 'false';
            });

            // Randomize other options
            ['speed', 'hue', 'saturation', 'lightness'].forEach(id => {
                const input = getEl(id);
                if (!input) return;
                const randomValue = Math.floor(Math.random() * 16);
                input.value = randomValue;
                input.dataset.hexValue = randomValue.toString(16);
            });
            controlState.update();
        }

        getEl('options').append(
            ...['speed', 'hue', 'saturation', 'lightness'].map(id =>
                createRangeInput({ id, label: id }))
        )

        // Try loading from URL first, fallback to random
        if (!loadSeedFromUrl()) {
            randomizeOptions();
        } else {
            controlState.update();
        }

        // Add click handler to seed element
        getEl('seed').addEventListener('click', async () => {
            window.location.hash = controlState.seed
            try {
                await navigator.clipboard.writeText(window.location.href)
                const toast = query('.toast')
                toast.classList.add('show')
                setTimeout(() => toast.classList.remove('show'), 2000)
            } catch (err) {
                console.error('Failed to copy URL:', err)
            }
        })

        // Add button to randomize values again
        const randomizeBtn = mkEl('button', {
            textContent: 'Randomize',
            onclick: randomizeOptions,
            className: 'shader',
            style: 'width: 100%;'
        });
        getEl('options').appendChild(randomizeBtn);

        // Add toggle buttons
        const main = query('main');
        const usage = query('.usage');

        const mainToggle = mkEl('button', {
            id: 'toggle',
            // textContent: 'Hide',
            onclick: () => {
                controlState.isVisible = !controlState.isVisible;
                main.classList.toggle('hidden');
                usage.classList.toggle('hidden');
                // mainToggle.textContent = controlState.isVisible ? 'Hide' : 'Show';
            }
        });

        document.body.appendChild(mainToggle);
    </script>
</body>

</html>